#!/bin/bash

# =======================================================================================
#
#                    *** Ubuntu Smart Two-Stage Upgrade Script ***
#
# This smart script automatically detects your current Ubuntu version and executes
# the appropriate upgrade stage.
#
# Execution Flow:
#   1. Run on Ubuntu 20.04:
#      - The script performs all necessary preparations (including AIDE config) and
#        upgrades the system to 22.04.
#      - After completion, please reboot the system.
#
#   2. Run the same script again on the upgraded Ubuntu 22.04 system:
#      - The script will detect the new version, perform the second-stage preparations,
#        and upgrade the system to 24.04.
#
# =======================================================================================

# --- Global Settings & Constants ---
set -e
PROXY_URL="http://10.33.35.10:8080"
CA_CERT_FILENAME="root-ca.crt"
CA_CERT_PATH="/usr/local/share/ca-certificates/${CA_CERT_FILENAME}"

#
# ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼【 USER CONFIGURATION AREA 】▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
#
# Please paste your complete CA certificate content between the quotes below.
#
CA_CERT_CONTENT="""
-----BEGIN CERTIFICATE-----
*** PASTE YOUR CA CERTIFICATE CONTENT HERE ***
-----END CERTIFICATE-----
"""
#
# ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲【 END OF CONFIGURATION 】▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
#

# --- Function Definitions ---
log() {
    echo ""
    echo "=================================================="
    echo " $1"
    echo "=================================================="
    echo ""
}

check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        echo "Error: This script must be run with root privileges. Please use 'sudo ./smart_upgrade.sh'" >&2
        exit 1
    fi
}

check_ca_content() {
    if [[ "$CA_CERT_CONTENT" == *"PASTE YOUR CA CERTIFICATE CONTENT HERE"* ]]; then
        log "Error: Please edit this script file first."
        echo "You must paste your CA certificate content into the 'CA_CERT_CONTENT' variable before running." >&2
        exit 1
    fi
}

# Full proxy setup (for stage 1)
setup_proxy() {
    log "Setting up System and APT Proxy"
    echo "--> Creating proxy configuration file for APT..."
    cat <<EOF > /etc/apt/apt.conf.d/99proxy
Acquire::http::Proxy "${PROXY_URL}";
Acquire::https::Proxy "${PROXY_URL}";
Acquire::ftp::Proxy "${PROXY_URL}";
EOF
    echo "--> APT proxy configuration complete: /etc/apt/apt.conf.d/99proxy"
    echo "--> Adding proxy settings to /etc/environment..."
    grep -qxF "http_proxy=\"${PROXY_URL}\"" /etc/environment || echo "http_proxy=\"${PROXY_URL}\"" >> /etc/environment
    grep -qxF "https_proxy=\"${PROXY_URL}\"" /etc/environment || echo "https_proxy=\"${PROXY_URL}\"" >> /etc/environment
    echo "--> System proxy configuration complete: /etc/environment"
}

# Full CA certificate installation (for stage 1)
install_and_update_ca() {
    log "Installing and Updating CA Certificate"
    echo "${CA_CERT_CONTENT}" > "${CA_CERT_PATH}"
    chmod 644 "${CA_CERT_PATH}"
    echo "--> Certificate has been written to ${CA_CERT_PATH}"
    update-ca-certificates
    echo "--> System certificate store has been updated."
}

# Verify proxy and CA (for stage 2)
verify_proxy_and_ca() {
    log "Verifying Proxy and CA Certificate Settings"
    if [ ! -f "/etc/apt/apt.conf.d/99proxy" ]; then
        echo "--> Warning: APT proxy configuration not found. Re-configuring..."
        setup_proxy
    else
        echo "--> APT proxy configuration already exists."
    fi

    if [ ! -f "${CA_CERT_PATH}" ]; then
        echo "--> Warning: CA certificate file not found. Re-installing..."
        install_and_update_ca
    else
        echo "--> CA certificate already exists."
    fi
}

# System stabilization (runs in both stages)
stabilize_system() {
    log "Stabilizing System and Performing Deep Clean"
    echo "--> Clearing old crash reports"
    rm -f /var/crash/*
    echo "--> Running apt update..."
    apt-get update
    echo "--> Running apt upgrade (preserving local configuration files)..."
    DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" upgrade -y
    echo "--> Running apt dist-upgrade (preserving local configuration files)..."
    DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confold" dist-upgrade -y
    echo "--> Fixing any broken package dependencies..."
    DEBIAN_FRONTEND=noninteractive apt-get --fix-broken install -y
    echo "--> Reconfiguring any pending dpkg packages..."
    dpkg --configure -a
    echo "--> Autoremoving and purging old packages..."
    DEBIAN_FRONTEND=noninteractive apt-get autoremove --purge -y
    echo "--> Cleaning up local package cache..."
    apt-get clean
    echo "--> System stabilization and cleanup complete."
}

# Standardized PAM configuration upgrade using pam-auth-update (for stage 1)
update_pam_configuration_standard() {
    log "Upgrading PAM Configuration: Setting up pam_faillock with pam-auth-update"

    # --- Part 1: Disable legacy pam_tally modules ---
    PAM_DIR="/etc/pam.d"
    echo "--> Searching for legacy pam_tally/pam_tally2 modules..."
    TALLY_FILES=$(mktemp)
    grep -lrwE "pam_tally.so|pam_tally2.so" "${PAM_DIR}" > "${TALLY_FILES}" || true
    if [ ! -s "${TALLY_FILES}" ]; then
        echo "--> No legacy pam_tally modules found. Skipping disablement."
    else
        echo "--> Found legacy PAM modules. Backing up and disabling..."
        while IFS= read -r file; do
            if [ -n "$file" ]; then
                BACKUP_FILE="${file}.bak.$(date +%F-%T)"
                cp "${file}" "${BACKUP_FILE}"
                sed -i.pre-upgrade -E 's/^(.*(pam_tally\.so|pam_tally2\.so).*)$/#\1/g' "${file}"
            fi
        done < "${TALLY_FILES}"
        echo "--> Legacy PAM modules disabled."
    fi
    rm -f "${TALLY_FILES}"

    # --- Part 2: Create pam-auth-update config file for pam_faillock ---
    FAILLOCK_CONFIG_FILE="/usr/share/pam-configs/faillock"
    echo "--> Checking for faillock config file for pam-auth-update..."
    if [ -f "${FAILLOCK_CONFIG_FILE}" ]; then
        echo "--> Config file ${FAILLOCK_CONFIG_FILE} already exists. No creation needed."
    else
        echo "--> Creating ${FAILLOCK_CONFIG_FILE}..."
        cat <<'EOF' > "${FAILLOCK_CONFIG_FILE}"
Name: Lock out accounts after failed logins
Default: yes
Priority: 900
Auth-Type: Primary
Auth:
	[success=1 default=ignore]	pam_faillock.so preauth audit silent deny=5 unlock_time=900
	required			pam_faillock.so authfail audit deny=5 unlock_time=900
Account-Type: Primary
Account:
	required			pam_faillock.so
EOF
        echo "--> faillock config file created."
    fi

    # --- Part 3: Run pam-auth-update non-interactively ---
    echo "--> Enabling faillock profile with pam-auth-update..."
    pam-auth-update --enable faillock
    echo "--> pam-auth-update executed."

    # --- Part 4: Clean up old log files ---
    echo "--> Removing old tally log files..."
    rm -f /var/log/faillog /var/log/tallylog
    echo "--> PAM configuration upgrade complete."
}

# Vim plugin cleanup (for stage 1)
handle_vim_plugin_cleanup() {
    log "Performing User-Specific Configuration Cleanup (Vim)"
    VIMRC_FILE="/root/.vimrc"

    if [ ! -f "${VIMRC_FILE}" ]; then
        echo "--> ${VIMRC_FILE} not found. Skipping Vim plugin cleanup."
        return
    fi

    # List of plugins to disable and clean
    PLUGINS_TO_DISABLE=(
        "tpope/vim-fugitive"
        "Yggdroot/indentLine"
    )

    changes_made=false

    for plugin in "${PLUGINS_TO_DISABLE[@]}"; do
        # Check if plugin exists and is not already commented out
        if grep -q "^\s*Plug '${plugin}'" "${VIMRC_FILE}"; then
            if ! $changes_made; then
                # Only back up once, on the first change found
                VIMRC_BACKUP="/root/.vimrc.bak.$(date +%F-%T)"
                echo "--> Found plugins to clean. Backing up ${VIMRC_FILE} to ${VIMRC_BACKUP}"
                cp "${VIMRC_FILE}" "${VIMRC_BACKUP}"
                changes_made=true
            fi
            
            echo "--> Commenting out plugin: ${plugin}"
            # Use a different delimiter to avoid issues with slashes in the path
            sed -i.vim-cleanup "s|^\s*Plug '${plugin}'|\"&|" "${VIMRC_FILE}"
        else
            echo "--> Plugin '${plugin}' not found or already commented out. Skipping."
        fi
    done

    # If any changes were made, run PlugClean
    if $changes_made; then
        echo "--> Running 'PlugClean' to remove commented plugins..."
        if command -v vim &> /dev/null; then
            # Use PlugClean! to run non-interactively. Wrap in try/catch to prevent
            # errors if vim-plug is not installed properly, which would halt the script.
            vim -u "${VIMRC_FILE}" -c "try | PlugClean! | catch | endtry" -c "qa!"
            echo "--> Vim 'PlugClean' process completed."
        else
            echo "--> Warning: 'vim' command not found. Cannot run PlugClean automatically."
        fi
    else
        echo "--> No Vim plugins needed cleaning."
    fi

    echo "--> Vim cleanup complete."
}


# Configure AIDE (for stage 1)
configure_aide() {
    log "Configuring AIDE Ignore Rules"
    AIDE_CONF="/etc/aide/aide.conf"

    if [ ! -f "${AIDE_CONF}" ]; then
        echo "--> AIDE config file (${AIDE_CONF}) not found. Skipping this step."
        return
    fi

    echo "--> Checking and adding AIDE ignore rules..."
    
    # Create a backup before modifying
    cp "${AIDE_CONF}" "${AIDE_CONF}.bak.$(date +%F-%T)"

    # List of rules to add
    RULES_TO_ADD=(
        "!/var/log"
        "!/run"
        "!/tmp"
        "!/data"
    )

    for rule in "${RULES_TO_ADD[@]}"; do
        # Use grep -qF -- to treat the rule as a fixed string and avoid issues with special characters
        if grep -qF -- "${rule}" "${AIDE_CONF}"; then
            echo "--> Rule '${rule}' already exists."
        else
            echo "--> Adding rule: ${rule}"
            # Append the rule to the end of the file
            echo "${rule}" >> "${AIDE_CONF}"
        fi
    done

    echo "--> AIDE configuration complete."
}


# Run the release upgrade (runs in both stages)
run_release_upgrade() {
    log "Preparing for Release Upgrade"
    echo "WARNING! The operating system release upgrade is about to begin."
    echo "This process can be lengthy and will require your interaction to confirm certain options."
    echo "It is STRONGLY recommended to back up all critical data before proceeding!"
    read -p "Have you read the warning and wish to continue? (y/N): " choice
    case "$choice" in
      y|Y )
        echo "--> Remounting /tmp with execution permissions to ensure a smooth upgrade..."
        mount -o remount,exec /tmp
        echo "Starting do-release-upgrade..."
        export http_proxy="${PROXY_URL}"
        export https_proxy="${PROXY_URL}"
        do-release-upgrade
        ;;
      * )
        echo "Operation cancelled by user."
        exit 0
        ;;
    esac
}

# --- Main Execution Block ---
main() {
    check_root
    check_ca_content

    # Detect OS version
    if [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        OS_VERSION=$DISTRIB_RELEASE
    else
        echo "Error: Could not detect Ubuntu version."
        exit 1
    fi

    log "Detected current Ubuntu version: ${OS_VERSION}"

    case "$OS_VERSION" in
        "20.04")
            log "Starting Stage 1 Upgrade: 20.04 -> 22.04"
            setup_proxy
            install_and_update_ca
            stabilize_system
            update_pam_configuration_standard
            handle_vim_plugin_cleanup
            configure_aide
            run_release_upgrade
            log "Stage 1 upgrade process has been initiated. After it completes, please REBOOT the system, then run this script again for the final upgrade to 24.04."
            ;;
        "22.04")
            log "Starting Stage 2 Upgrade: 22.04 -> 24.04"
            verify_proxy_and_ca
            stabilize_system
            run_release_upgrade
            log "Stage 2 upgrade process has been initiated. Please reboot after completion."
            ;;
        "24.04")
            log "System is already at the latest supported version (24.04). No action needed."
            exit 0
            ;;
        *)
            log "Error: Unsupported Ubuntu version (${OS_VERSION})."
            echo "This script only supports upgrading from 20.04 or 22.04."
            exit 1
            ;;
    esac
}

# Invoke the main function
main
exit 0
